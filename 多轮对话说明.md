# 多轮对话功能说明

## 功能概述

已完善的多轮对话功能，支持上下文记忆，让 AI 能够记住之前的对话内容并进行连贯的多轮交互。

## 实现原理

### 1. 后端实现 (app/api/chat/route.ts)

使用 Google Gemini 的 Chat API 实现多轮对话：

```typescript
// 将消息历史转换为 Gemini 格式
const history = messages.slice(0, -1).map(msg => ({
  role: msg.role === "assistant" ? "model" : "user",
  parts: [{ text: msg.content }]
}));

// 创建聊天会话，传入历史记录
const chat = ai.chats.create({
  model: modelName,
  history: history.length > 0 ? history : undefined,
});

// 使用流式发送最新消息
const response = await chat.sendMessageStream({
  message: lastMessage,
});
```

**关键点：**
- `messages.slice(0, -1)` 提取除最后一条外的所有历史消息
- 将角色 `assistant` 转换为 Gemini 的 `model`
- 最后一条用户消息单独通过 `sendMessageStream` 发送

### 2. 前端实现 (components/home/Main/ChatInput.tsx)

前端发送完整的消息列表：

```typescript
async function doSend(messages: Message[]) {
  const body: MessageRequestBody = {messages, model: currentModel}
  // 发送完整的对话历史
  const response = await fetch("/api/chat", {
    method: "POST",
    body: JSON.stringify(body)
  })
}
```

### 3. 类型定义 (types/chat.ts)

新增 Gemini 多轮对话格式的类型：

```typescript
export interface GeminiPart {
  text: string
}

export interface GeminiContent {
  role: "user" | "model"
  parts: GeminiPart[]
}
```

## 使用示例

### 场景 1：连续提问

**用户：** 我有 2 只狗在家里。

**AI：** 太好了！养狗是一件很有趣的事情。它们是什么品种的呢？

**用户：** 我家里有多少只爪子？（AI 能记住前面说的 2 只狗）

**AI：** 每只狗有 4 只爪子，2 只狗总共有 8 只爪子！

### 场景 2：持续对话

**用户：** 给我推荐一本编程书。

**AI：** 我推荐《代码整洁之道》...

**用户：** 这本书适合初学者吗？（AI 知道"这本书"指的是什么）

**AI：** 《代码整洁之道》更适合有一定编程基础的开发者...

### 场景 3：上下文修正

**用户：** 写一个 Python 函数计算斐波那契数列。

**AI：** [提供 Python 代码]

**用户：** 改成 JavaScript 版本。（AI 知道要改什么）

**AI：** [提供 JavaScript 版本的相同功能]

## 技术细节

### 消息流转过程

1. **用户输入消息** → 保存到数据库和 messageList
2. **组装完整历史** → `messageList.concat([新消息])`
3. **发送到后端** → POST /api/chat，包含所有历史消息
4. **后端处理**：
   - 提取历史记录（除最后一条）
   - 创建 Gemini Chat 会话
   - 流式发送最新消息
5. **前端接收** → 实时显示 AI 响应
6. **保存响应** → 更新数据库和 messageList

### 调试日志

已在关键位置添加日志输出：

**前端：**
```typescript
console.log("发送多轮对话，消息数量:", messages.length)
console.log("对话历史:", messages.map(m => `${m.role}: ${m.content.substring(0, 30)}...`))
```

**后端：**
```typescript
console.log("完整对话历史:", messages.map(m => `${m.role}: ${m.content.substring(0, 50)}...`))
console.log("开始调用 Gemini API (多轮对话模式)...")
```

## 对比：单轮 vs 多轮

### 旧实现（单轮）
```typescript
// ❌ 只发送最后一条消息，无上下文
const prompt = messages[messages.length - 1].content;
const response = await ai.models.generateContentStream({
  model: modelName,
  contents: prompt,
});
```

### 新实现（多轮）
```typescript
// ✅ 发送完整历史，保持上下文
const history = messages.slice(0, -1).map(msg => ({...}));
const chat = ai.chats.create({
  model: modelName,
  history: history,
});
const response = await chat.sendMessageStream({
  message: lastMessage,
});
```

## 注意事项

1. **性能考虑**：每次请求都会发送完整历史，对话越长，请求体积越大
2. **Token 限制**：Gemini 有 token 上限，超长对话可能需要截断历史
3. **上下文保持**：切换聊天时，`chatIdRef` 会重置，确保不会混淆不同对话的上下文

## 未来优化方向

1. **历史截断策略**：当对话过长时，只保留最近 N 轮对话
2. **上下文摘要**：对历史对话进行摘要，减少 token 使用
3. **缓存优化**：利用 Gemini 的缓存功能，提高响应速度
4. **流式历史**：支持从数据库动态加载历史记录
